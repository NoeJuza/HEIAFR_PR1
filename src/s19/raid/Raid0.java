
package s19.raid;

// A Raid0 uses a group of small disks to simulate a larger one. This is how
// the memory cells should be dispatched among the members:
//   {00,03,06,09,12}  ← member 0
//   {01,04,07,10,13}  ← member 1
//   {02,05,08,11,14}  ← member 2
// As soon as any member faces a read/write error, the whole Raid0 must be
// considered as definitely broken (ie every subsequent read/write will throw
// a DeadDiskException.

// This skeleton has been automatically generated by IntelliJ IDEA...
// Please verify/adapt everything!

public class Raid0 extends Raid {

  public Raid0(DiskDevice[] members) {
    super(members);
  }

  @Override
  public int capacity() {
    // the parent class knows the common capacity among all disk members
    return 0;  // TODO
  }

  @Override
  public byte readAt(int index) throws DeadDiskException, InvalidIndexException {
    // Unless the index is invalid or the Raid0 disk is dead, we must redirect
    // the operation on the right disk, at the right index
    return 0;  // TODO
  }

  @Override
  public void writeAt(int index, byte data) throws DeadDiskException, InvalidIndexException {
    // Unless the index is invalid or the Raid0 disk is dead, we must redirect
    // the operation on the right disk, at the right index
    // TODO
  }
}